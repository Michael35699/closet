{"version":3,"file":"Main.js","sources":["../../../src/utils.ts","../../../src/template.ts","../../../node_modules/nearley/lib/nearley.js","../../../src/parser/tokenizer.ts","../../../node_modules/moo/moo.js","../../../src/tags/tagPure.ts","../../../src/tags/tagInfo.ts","../../../src/parser/tagMaker.ts","../../../src/parser/tagKeeper.ts","../../../src/parser/template.ts","../../../src/parser/index.ts","../../../src/main.ts","../../../src/filterManager/memoizer.ts","../../../src/filterManager/store.ts","../../../src/filterManager/filters.ts","../../../src/filterManager/deferred.ts","../../../src/filterManager/index.ts","../../../src/filterManager/recipes/mix.ts","../../../src/filterManager/recipes/index.ts","../../../src/filterManager/recipes/ord.ts","../../../src/filterManager/recipes/cloze.ts","../../../src/filterManager/recipes/mc.ts","../../../src/filterManager/recipes/debug.ts","../../../src/index.ts"],"sourcesContent":["export const TAG_START = '[['\nexport const TAG_END = ']]'\n\nexport const ARG_SEP = '::'\nexport const ALT_SEP = '||'\n\nconst spliceSlice = (str: string, lend: number, rend: number, add: string = ''): string => {\n    // We cannot pass negative lend directly to the 2nd slicing operation.\n    const leftend = lend < 0\n        ? Math.min(0, str.length + lend)\n        : lend\n\n    return str.slice(0, leftend) + add + str.slice(rend)\n}\n\nexport const pureReplace = (\n    text: string,\n    replacement: string,\n    lend: number,\n    rend: number,\n): [string, string] => {\n    const newValuesRaw = text.slice(lend, rend)\n    const newText = spliceSlice(text, lend, rend, replacement)\n\n    return [\n        newValuesRaw,\n        newText,\n    ]\n}\n\nexport const calculateCoordinates = (\n    tagStart: number,\n    tagEnd: number,\n    leftOffset: number,\n    innerOffset: number,\n): [number, number] => {\n    return [\n        tagStart + leftOffset,\n        tagEnd + leftOffset + innerOffset\n    ]\n}\n\nexport const getNewOffset = (replacement: string, tagEnd: number, tagStart: number): number => {\n    return replacement.length - (tagEnd - tagStart)\n}\n","import { TagInfo, Tag } from './tags'\nimport parseText from './parser'\n\nimport {\n    pureReplace,\n    calculateCoordinates,\n    getNewOffset,\n} from './utils'\n\ntype TagPath = number[]\n\nclass TemplateApi {\n    private rootTag: TagInfo\n    private zoom: TagPath\n\n    constructor(rootTag: TagInfo) {\n        this.rootTag = rootTag\n        this.zoom = []\n    }\n\n    private traverse(path = this.zoom): TagInfo | null {\n        let currentPos = this.rootTag\n\n        for (const p of path) {\n            if (currentPos.innerTags[p]) {\n                currentPos = currentPos.innerTags[p]\n            }\n\n            else {\n                return null\n            }\n        }\n\n        return currentPos\n    }\n\n    exists(path = this.zoom): boolean {\n        const resultTag = this.traverse(path)\n\n        return resultTag\n            ? true\n            : false\n    }\n\n    getTagInfo(path = this.zoom): TagInfo | null {\n        return this.traverse(path)\n    }\n\n    getTag(path = this.zoom): Tag | null {\n        const maybeTagInfo = this.traverse(path)\n\n        if (maybeTagInfo) {\n            return maybeTagInfo.data\n        }\n\n        return null\n    }\n\n    getOffsets(path = this.zoom): [number, number] | null {\n        const maybeTagInfo = this.traverse(path)\n\n        if (maybeTagInfo) {\n            return [0, maybeTagInfo.start]\n        }\n\n        return null\n    }\n\n    setZoom(path: TagPath): void {\n        this.zoom = path\n    }\n}\n\nexport default TemplateApi\n","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var lines = [];\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        lines.push(this.lexer.formatError(token, \"Syntax error\"));\n        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        // Display a \"state stack\" for each expectant state\n        // - which shows you how this state came to be, step by step.\n        // If there is more than one derivation, we only display the first one.\n        var stateStacks = expectantStates\n            .map(function(state) {\n                return this.buildFirstStateStack(state, []) || [state];\n            }, this);\n        // Display each state that is expecting a terminal symbol next.\n        stateStacks.forEach(function(stateStack) {\n            var state = stateStack[0];\n            var nextSymbol = state.rule.symbols[state.dot];\n            var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n            lines.push('A ' + symbolDisplay + ' based on:');\n            this.displayStateStack(stateStack, lines);\n        }, this);\n\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    };\n\n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ⬆ ︎' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\" && symbol.literal) {\n            return JSON.stringify(symbol.literal);\n        } else if (type === \"object\" && symbol instanceof RegExp) {\n            return 'character matching ' + symbol;\n        } else if (type === \"object\" && symbol.type) {\n            return symbol.type + ' token';\n        } else {\n            throw new Error('Unknown symbol type: ' + symbol);\n        }\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","import moo from 'moo'\n\nimport {\n    TAG_START,\n    TAG_END,\n    ARG_SEP,\n} from '../utils'\n\n// img tags are parsed via HTML (!)\nexport const tokenizer = moo.states({\n    main: {\n        tagstart: {\n            match: TAG_START,\n            push: 'key',\n        },\n        EOF: {\n            match: /\\$$/u,\n        },\n        text: {\n            match: /[\\s\\S]+?(?=\\[\\[|\\$$)/u,\n            lineBreaks: true,\n        },\n    },\n\n    key: {\n        keyname: {\n            match: /[a-zA-Z]+\\d*/u,\n        },\n        sep: {\n            match: ARG_SEP,\n            next: 'intag',\n        },\n        tagend: {\n            match: TAG_END,\n            pop: 1,\n        },\n    },\n\n    intag: {\n        tagstart: {\n            match: TAG_START,\n            push: 'key',\n        },\n        tagend: {\n            match: TAG_END,\n            pop: 1,\n        },\n        valuestext: {\n            match: /[\\s\\S]+?(?=\\[\\[|\\]\\])/u,\n            lineBreaks: true,\n        },\n    },\n})\n\nexport default tokenizer\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    var start = Math.max(0, token.offset - token.col + 1)\n    var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length\n    var firstLine = this.buffer.substring(start, token.offset + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","import {\n    TAG_START,\n    TAG_END,\n    ARG_SEP,\n} from '../utils'\n\nconst splitValues = (valuesRaw: string | null): string[][] =>\n    valuesRaw === null\n        ? []\n        : valuesRaw.split(ARG_SEP).map(arg => arg.split('||'))\n\nclass Tag {\n    readonly fullKey: string\n    readonly key: string\n    readonly num: number | null\n\n    readonly valuesRaw: string\n    readonly values: string[][]\n\n    readonly fullOccur: number\n    readonly occur: number\n\n    readonly path: number[]\n\n    constructor(\n        fullKey: string,\n        key: string,\n        num: number | null,\n        valuesRaw: string | null,\n        fullOccur: number,\n        occur: number,\n        path: number[],\n    ) {\n        this.fullKey = fullKey\n        this.key = key\n        this.num = num\n\n        this.valuesRaw = valuesRaw\n        this.values = splitValues(valuesRaw)\n\n        this.fullOccur = fullOccur\n        this.occur = occur\n\n        this.path = path\n    }\n\n    shadowValuesRaw(newValuesRaw: string): Tag {\n        return new Tag(\n            this.fullKey,\n            this.key,\n            this.num,\n            newValuesRaw,\n            this.fullOccur,\n            this.occur,\n            this.path,\n        )\n    }\n\n    makeMemoizerKey(): string {\n        return `${this.key}:${this.num}:${this.valuesRaw}`\n    }\n\n    getDefaultRepresentation(): string {\n        return this.valuesRaw === null\n            ? `${TAG_START}${this.fullKey}${TAG_END}`\n            : `${TAG_START}${this.fullKey}${ARG_SEP}${this.valuesRaw}${TAG_END}`\n    }\n\n    getRawRepresentation(): string {\n        return this.valuesRaw ?? ''\n    }\n\n    getFilterKey(): string {\n        return this.key\n    }\n}\n\nexport default Tag\n","import Tag from './tagPure'\n\nclass TagInfo {\n    readonly start: number\n    private _end: number\n    private _ready: boolean\n\n    private _data: Tag\n    readonly innerTags: TagInfo[]\n\n    private _naked: boolean\n\n    constructor(start: number) {\n        this.start = start\n        this._ready = false\n\n        this.innerTags = []\n    }\n\n    close(end: number, data: Tag, naked: boolean) {\n        this._end = end\n        this._data = data\n        this._naked = naked\n    }\n\n    get end() {\n        return this._end\n    }\n\n    get data() {\n        return this._data\n    }\n\n    get naked() {\n        return this._naked\n    }\n\n    isReady() {\n        return this._ready\n    }\n\n    isReadyRecursive() {\n        return this._ready && this.innerTags.map(t => t.isReadyRecursive())\n    }\n\n    setReady(b: boolean) {\n        this._ready = b\n    }\n\n    addInnerTag(tag: TagInfo) {\n        this.innerTags.push(tag)\n    }\n}\n\nexport default TagInfo\n","import { Tag } from '../tags'\n\nconst keyPattern = /^([^0-9]+)([0-9]*)$/u\n\nclass TagMaker {\n    private readonly tagCounter: Map<string, number>\n\n    constructor() {\n        this.tagCounter = new Map()\n    }\n\n    private getAndInc(key: string): number {\n        const result = this.tagCounter.has(key)\n            ? this.tagCounter.get(key) + 1\n            : 0\n\n        this.tagCounter.set(key, result)\n        return result\n    }\n\n    makeTag(fullKey: string, valuesRaw: string | null, path: number[]): Tag {\n        const match = fullKey.match(keyPattern)\n\n        const key = match[1]\n        const idx = match[2].length === 0 ? null : Number(match[2])\n\n        const fullOccur = this.getAndInc(fullKey)\n        const occur = fullKey === key\n            ? fullOccur\n            : this.getAndInc(key)\n\n        return new Tag(\n            fullKey,\n            key,\n            idx,\n            valuesRaw,\n            fullOccur,\n            occur,\n            path,\n        )\n    }\n}\n\nexport default TagMaker\n","import {\n    TagInfo,\n} from '../tags'\n\nimport TagMaker from './tagMaker'\n\nconst tagKeeper = function*(): Generator<number[], TagInfo, [number, string?, string?, boolean?]> {\n    const tm = new TagMaker()\n    const rootTag = new TagInfo(0)\n\n    const getTagInfo = (path: number[]): TagInfo => {\n        let reference = rootTag\n\n        for (const id of path) {\n            reference = reference.innerTags[id]\n        }\n\n        return reference\n    }\n\n    const tagStack: number[] = []\n    let nextLevel = 0\n\n    while (true) {\n        let value = yield tagStack\n\n        if (value[0] >= 0) /* start */ {\n            const startIndex = value[0]\n            getTagInfo(tagStack).addInnerTag(new TagInfo(startIndex))\n\n            tagStack.push(nextLevel)\n            nextLevel = 0\n        }\n\n        else /* end */ {\n            const endIndex = Math.abs(value[0])\n            const fullKey = value[1]\n            const valuesRaw = value[2] ?? null\n            const naked = value[3]\n\n            const foundTag = getTagInfo(tagStack)\n            foundTag.close(endIndex, tm.makeTag(fullKey, valuesRaw, [...tagStack]), naked)\n\n            if (tagStack.length === 0) {\n                return rootTag\n            }\n            else {\n                nextLevel = tagStack.pop() + 1\n            }\n        }\n    }\n}\n\nclass TagKeeper {\n    tk: Generator<number[], TagInfo, [number, string?, string?, boolean?]>\n\n    constructor() {\n        this.tk = tagKeeper()\n        this.tk.next()\n    }\n\n    startToken(offset: number) {\n        return this.tk.next([offset])\n    }\n\n    endToken(offset: number, key: string, valuesRaw: string | null, naked = false) {\n        return this.tk.next([-offset, key, valuesRaw, naked])\n    }\n\n    restart() {\n        this.tk = tagKeeper()\n        this.tk.next()\n    }\n}\n\nexport default TagKeeper\n","// Generated automatically by nearley, version 2.19.2\n// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d: any[]): any { return d[0]; }\ndeclare var EOF: any;\ndeclare var tagend: any;\ndeclare var tagstart: any;\ndeclare var keyname: any;\ndeclare var sep: any;\ndeclare var valuestext: any;\ndeclare var text: any;\n\nimport tokenizer from './tokenizer'\nimport TagKeeper from './tagKeeper'\n\nimport {\n    TAG_START,\n    TAG_END,\n    ARG_SEP,\n} from '../utils'\n\nconst tagKeeper = new TagKeeper()\n\ninterface NearleyToken {  value: any;\n  [key: string]: any;\n};\n\ninterface NearleyLexer {\n  reset: (chunk: string, info: any) => void;\n  next: () => NearleyToken | undefined;\n  save: () => any;\n  formatError: (token: NearleyToken) => string;\n  has: (tokenType: string) => boolean;\n};\n\ninterface NearleyRule {\n  name: string;\n  symbols: NearleySymbol[];\n  postprocess?: (d: any[], loc?: number, reject?: {}) => any;\n};\n\ntype NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };\n\ninterface Grammar {\n  Lexer: NearleyLexer | undefined;\n  ParserRules: NearleyRule[];\n  ParserStart: string;\n};\n\nconst grammar: Grammar = {\n  Lexer: tokenizer,\n  ParserRules: [\n    {\"name\": \"start\", \"symbols\": [\"content\", (tokenizer.has(\"EOF\") ? {type: \"EOF\"} : EOF)], \"postprocess\": () => tagKeeper},\n    {\"name\": \"content$ebnf$1\", \"symbols\": []},\n    {\"name\": \"content$ebnf$1$subexpression$1\", \"symbols\": [\"tag\", \"_\"]},\n    {\"name\": \"content$ebnf$1\", \"symbols\": [\"content$ebnf$1\", \"content$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"content\", \"symbols\": [\"_\", \"content$ebnf$1\"]},\n    {\"name\": \"tag\", \"symbols\": [\"tagstart\", \"inner\", (tokenizer.has(\"tagend\") ? {type: \"tagend\"} : tagend)], \"postprocess\":  ([,[keyname, valuesRaw],tagend]) => [[\n            TAG_START,\n            `${keyname}${ARG_SEP}${valuesRaw}`,\n            TAG_END,\n        ], tagKeeper.endToken(tagend.offset + TAG_END.length, keyname, valuesRaw)] },\n    {\"name\": \"tagstart\", \"symbols\": [(tokenizer.has(\"tagstart\") ? {type: \"tagstart\"} : tagstart)], \"postprocess\": ([startToken]) => [startToken.value, tagKeeper.startToken(startToken.offset + startToken.value.length - TAG_START.length)]},\n    {\"name\": \"inner$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"inner$ebnf$1$subexpression$1$ebnf$1$subexpression$1\", \"symbols\": [\"tag\", \"_values\"]},\n    {\"name\": \"inner$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [\"inner$ebnf$1$subexpression$1$ebnf$1\", \"inner$ebnf$1$subexpression$1$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"inner$ebnf$1$subexpression$1\", \"symbols\": [(tokenizer.has(\"sep\") ? {type: \"sep\"} : sep), \"_values\", \"inner$ebnf$1$subexpression$1$ebnf$1\"]},\n    {\"name\": \"inner$ebnf$1\", \"symbols\": [\"inner$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"inner$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"inner\", \"symbols\": [(tokenizer.has(\"keyname\") ? {type: \"keyname\"} : keyname), \"inner$ebnf$1\"], \"postprocess\":  ([key,rest]) => rest\n        ? [key.value, rest[1] + rest[2].map(([tag, vtxt]) => id(tag).join('') + vtxt)]\n        : [key.value],\n        },\n    {\"name\": \"_values$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_values$ebnf$1\", \"symbols\": [\"_values$ebnf$1\", (tokenizer.has(\"valuestext\") ? {type: \"valuestext\"} : valuestext)], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"_values\", \"symbols\": [\"_values$ebnf$1\"], \"postprocess\": ([vs]) => vs.map(v => v.value).join('')},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", (tokenizer.has(\"text\") ? {type: \"text\"} : text)], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"], \"postprocess\": () => null}\n  ],\n  ParserStart: \"start\",\n};\n\nexport default grammar;\n","import nearley from 'nearley'\nimport grammar from './template'\n\nimport { TagInfo } from '../tags'\n\nconst parseTemplate = (text: string): TagInfo => {\n    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar))\n    const parsed = parser.feed(text + '$').results\n\n    if (parsed.length > 1) {\n        console.error('Ambiguous template grammar')\n    }\n    else if (parsed.length < 1) {\n        console.error('Template grammar does not match')\n    }\n\n    const result = parsed[0].endToken(text.length, 'base', text, true).value\n    parsed[0].restart()\n\n    return result\n}\n\nexport default parseTemplate\n","import type {\n    FilterManager,\n    FilterProcessor,\n} from './filterManager'\n\nimport {\n    calculateCoordinates,\n} from './utils'\n\nimport type {\n    TagInfo,\n} from './tags'\n\nimport TemplateApi from './template'\n\nimport parseTemplate from './parser'\n\nimport {\n    TAG_START,\n    TAG_END,\n    ARG_SEP,\n} from './utils'\n\nconst MAX_ITERATIONS = 50\n\nconst renderTemplate = (text: string, filterManager: FilterManager): string => {\n    let result = text\n    let ready = false\n\n    for (let i = 0; i < MAX_ITERATIONS && !ready; i++) {\n        const rootTag = parseTemplate(result)\n        const templateApi = new TemplateApi(rootTag)\n\n        console.error('ITERATION: ', i, result, ready)\n\n        const [\n            newText,\n            finalOffset,\n            innerReady,\n        ] = postfixTraverse(result, rootTag, filterManager.filterProcessor({\n            iteration: { index: i },\n            template: templateApi,\n        }))\n\n        ready = innerReady\n        result = newText\n\n        filterManager.executeAndClearDeferred()\n    }\n\n        return result\n}\n\nconst spliceSlice = (str: string, lend: number, rend: number, add: string = ''): string => {\n    // We cannot pass negative lend directly to the 2nd slicing operation.\n    const leftend = lend < 0\n        ? Math.min(0, str.length + lend)\n        : lend\n\n    return str.slice(0, leftend) + add + str.slice(rend)\n}\n\n// try to make it more PDA\nconst postfixTraverse = (baseText: string, rootTag: TagInfo, filterProcessor: FilterProcessor): [string, number[], boolean]=> {\n    const tagReduce = ([text, stack, ready]: [string, number[], boolean], tag: TagInfo): [string, number[], boolean] => {\n\n        // going DOWN\n        stack.push(stack[stack.length - 1])\n        // console.info('going down', tag.data.path)\n\n        const [\n            modText,\n            modStack,\n            modReady,\n        ] = tag.innerTags.reduce(tagReduce, [text, stack, true])\n\n        // get offsets\n        modStack.push(modStack.pop() - modStack[modStack.length - 1])\n\n        const innerOffset = modStack.pop()\n        const leftOffset = modStack.pop()\n\n        ///////////////////// Updating valuesRaw and values with innerTags\n        const [\n            lend,\n            rend,\n        ] = calculateCoordinates(tag.start, tag.end, leftOffset, innerOffset)\n\n        const newValuesRaw = modText.slice(\n            lend + (tag.naked ? 0 : TAG_START.length + tag.data.fullKey.length + ARG_SEP.length),\n            rend - (tag.naked ? 0 : TAG_END.length),\n        )\n\n        const tagData = tag.data.shadowValuesRaw(newValuesRaw)\n        console.log('data?', modText, tag.naked, tag.data.valuesRaw, newValuesRaw)\n\n        ///////////////////// Evaluate current tag\n        const filterOutput = filterProcessor(tagData, { ready: modReady })\n        const newOffset = filterOutput.ready\n            ? filterOutput.result.length - (rend - lend)\n            : 0\n\n        console.info('OFFSETS:', tag.data.path, 'i,l,n:', innerOffset, leftOffset, newOffset)\n\n        const newText = filterOutput.ready\n            ? spliceSlice(modText, lend, rend, filterOutput.result)\n            : modText\n\n        // going UP\n        const sum = innerOffset + leftOffset + newOffset\n        modStack.push(sum)\n        console.info('going up', tag.data.path, modText, '+++', filterOutput.result, '===', newText, modStack)\n\n        return [\n            newText,\n            modStack,\n            // ready means everything to the left is ready\n            // filterOutput.ready means everything within and themselves are ready\n            ready && filterOutput.ready\n        ]\n    }\n\n    return tagReduce([baseText, [0,0], true], rootTag)\n}\n\nexport default renderTemplate\n","import type {\n    FilterResult,\n} from './filters'\n\nexport interface MemoizerKeyable {\n    makeMemoizerKey(): string\n}\n\nexport interface Memoizer {\n    hasItem(k: MemoizerKeyable): boolean\n    getItem(k: MemoizerKeyable): FilterResult\n    setItem(k: MemoizerKeyable, v: FilterResult): void\n    removeItem(k: MemoizerKeyable): void\n    clear(): void\n    raw?(): unknown\n}\n\nconst map: Map<string, FilterResult> = new Map()\nexport const defaultMemoizer:  Memoizer = {\n    hasItem: (k: MemoizerKeyable) => map.has(k.makeMemoizerKey()),\n    getItem: (k: MemoizerKeyable) => map.get(k.makeMemoizerKey()),\n    setItem: (k: MemoizerKeyable, v: FilterResult) => map.set(k.makeMemoizerKey(), v),\n    removeItem: (k: MemoizerKeyable) => map.delete(k.makeMemoizerKey()),\n    clear: () => map.clear(),\n}\n","export class Store {\n    private store: Map<string, unknown>\n\n    constructor() {\n        this.store = new Map()\n    }\n\n    set(name: string, value: unknown): void {\n        this.store.set(name, value)\n    }\n\n    has(name: string): boolean {\n        return this.store.has(name)\n    }\n    get(name: string, defaultValue: unknown = null): unknown {\n        return this.has(name)\n            ? this.store.get(name)\n            : defaultValue\n    }\n\n    fold(name: string, f: (v: unknown) => unknown, mempty: unknown): void {\n        this.set(name, f(this.get(name, mempty)))\n    }\n\n    over(name: string, f: (v: unknown) => void, mempty: unknown): void {\n        if (!this.has(name)) {\n            f(mempty)\n            this.set(name, mempty)\n        }\n\n        else {\n            f(this.get(name, mempty))\n        }\n    }\n\n    delete(name: string): void {\n        this.store.delete(name)\n    }\n\n    clear(): void {\n        this.store.clear()\n    }\n}\n","import type {\n    Internals,\n} from '.'\n\nexport interface FilterResult {\n    result: string\n    memoize?: boolean\n}\n\nexport interface Filterable {\n    getDefaultRepresentation(): string\n    getRawRepresentation(): string\n    getFilterKey(): string\n}\n\nconst wrapWithNonMemoize = (result: string): FilterResult => ({\n    result: result,\n    memoize: false,\n})\n\nconst standardizeFilterResult = (wf: WeakFilter): Filter => (t: Filterable, i: Internals): FilterResult => {\n    const input = wf(t, i)\n\n    switch (typeof input) {\n        case 'string':\n            return wrapWithNonMemoize(input)\n\n        // includes null\n        case 'object':\n            return {\n                result: input.result,\n                memoize: input.memoize ?? false,\n            }\n\n        // undefined\n        default:\n            return {\n                // this will mark as \"not ready\"\n                result: null,\n                memoize: false,\n            }\n    }\n}\n\nexport type WeakFilter = (t: Filterable, i: Internals) => FilterResult | string\nexport type Filter = (t: Filterable, i: Internals) => FilterResult\n\nconst baseFilter = (t: Filterable, i: Internals) => i.ready ? wrapWithNonMemoize(t.getRawRepresentation()) : undefined\nconst rawFilter = (t: Filterable) => wrapWithNonMemoize(t.getRawRepresentation())\nconst defaultFilter = (t: Filterable) => wrapWithNonMemoize(t.getDefaultRepresentation())\n\nexport class FilterApi {\n    private filters: Map<string, WeakFilter>\n\n    constructor() {\n        this.filters = new Map()\n    }\n\n    register(name: string, filter: Filter): void {\n        this.filters.set(name, filter)\n    }\n\n    has(name: string): boolean {\n        return name === 'raw' || name === 'base'\n            ? true\n            : this.filters.has(name)\n    }\n\n    get(name: string): Filter | null {\n        return name === 'base'\n            ? baseFilter\n            : name === 'raw'\n            ? rawFilter\n            : this.filters.has(name)\n            ? standardizeFilterResult(this.filters.get(name))\n            : null\n    }\n\n    getOrDefault(name: string): Filter {\n        const maybeResult =  this.get(name)\n\n        if (maybeResult) {\n            return maybeResult\n        }\n\n        return defaultFilter\n    }\n\n    unregisterFilter(name: string): void {\n        this.filters.delete(name)\n    }\n\n    clearFilters(): void {\n        this.filters.clear()\n    }\n\n    execute(data: Filterable, internals: Internals): FilterResult {\n        return standardizeFilterResult(this.getOrDefault(data.getFilterKey()))(data, internals)\n    }\n}\n\n","export type Deferred = (name: string, ...rest: any[]) => void\n\nexport class DeferredApi {\n    private deferred: Map<string, Deferred>\n\n    constructor() {\n        this.deferred = new Map()\n    }\n\n    register(name: string, proc: Deferred): void {\n        this.deferred.set(name, proc)\n    }\n\n    registerIfNotExists(name: string, proc: Deferred): void {\n        if (!this.has(name)) {\n            this.register(name, proc)\n        }\n    }\n\n    has(name: string): boolean {\n        return this.deferred.has(name)\n    }\n\n    unregister(name: string): void {\n        this.deferred.delete(name)\n    }\n\n    clear(): void {\n        this.deferred.clear()\n    }\n\n    executeEach(...args: any[]): void {\n        for (const [name, func] of this.deferred) {\n            func(name, ...args)\n        }\n    }\n}\n","import type TemplateApi from '../template'\n\nimport {\n    Memoizer,\n    MemoizerKeyable,\n    defaultMemoizer,\n} from './memoizer'\n\nimport {\n    Store,\n} from './store'\n\nimport {\n    FilterApi,\n    Filterable,\n} from './filters'\n\nimport {\n    DeferredApi,\n} from './deferred'\n\n\nexport interface Internals {\n    store: Store\n    filters: FilterApi\n    deferred: DeferredApi\n    iteration: {index: number }\n    ready: boolean\n}\n\nexport interface StockInternals {\n    template: TemplateApi,\n    iteration: { index: number }\n}\n\nexport interface CustomInternals {\n    ready: boolean\n}\n\ninterface FilterProcessorResult {\n    result: string | null\n    ready: boolean\n}\n\nexport type FilterProcessor = (data: Filterable & MemoizerKeyable, custom?: object) => FilterProcessorResult\n\nconst notReady = {\n    result: null,\n    ready: false,\n}\n\nconst makeReady = (value: string): FilterProcessorResult => ({\n    result: value,\n    ready: true,\n})\n\nexport class FilterManager {\n    readonly filters: FilterApi\n    private readonly deferred: DeferredApi\n\n    private readonly store: Store\n    private readonly memoizer: Memoizer\n    private readonly preset: object\n\n    constructor(preset = {}, memoizer = defaultMemoizer) {\n        this.filters = new FilterApi()\n        this.deferred = new DeferredApi()\n\n        this.preset = preset\n        this.store = new Store()\n        this.memoizer = memoizer\n    }\n\n    filterProcessor(stock: StockInternals): FilterProcessor {\n        return (data: Filterable & MemoizerKeyable, custom: CustomInternals): FilterProcessorResult => {\n\n            if (this.memoizer.hasItem(data)) {\n                return {\n                    result: this.memoizer.getItem(data).result,\n                    ready: true,\n                }\n            }\n\n            const internals: Internals = Object.assign(this.preset, stock, custom, {\n                store: this.store,\n                filters: this.filters,\n                deferred: this.deferred,\n            })\n\n            const result = this.filters.execute(data, internals)\n\n            if (result.result === null) {\n                return notReady\n            }\n\n            if (result.memoize) {\n                this.memoizer.setItem(data, result)\n            }\n\n            return makeReady(result.result)\n        }\n    }\n\n    executeAndClearDeferred() {\n        this.deferred.executeEach()\n        this.deferred.clear()\n    }\n\n    reset() {\n        this.store.clear()\n    }\n\n    addRecipe(recipe: (filters: FilterApi) => void): void {\n        recipe(this.filters)\n    }\n}\n\nexport default FilterManager\n","import type {\n    Tag\n} from '../../tags'\n\nimport type {\n    FilterApi\n} from '../filters'\n\nimport type {\n    Internals,\n} from '..'\n\nconst id = (v: string): string => v\n\nconst mixRecipe = (\n    keyword: string,\n    separator: string,\n    mapper: (v: string) => string = id,\n    postprocess: (v: string) => string = id,\n) => (filterApi: FilterApi) => {\n    const shuffle = (array: unknown[]) => {\n        const result = array.slice(0)\n        let currentIndex = array.length, temporaryValue = null, randomIndex = null\n\n        // While there remain elements to shuffle...\n        while (currentIndex !== 0) {\n            // Pick a remaining element...\n            randomIndex = Math.floor(Math.random() * currentIndex)\n            currentIndex -= 1\n\n            // And swap it with the current element.\n            temporaryValue = result[currentIndex]\n            result[currentIndex] = result[randomIndex]\n            result[randomIndex] = temporaryValue\n        }\n\n        return result\n    }\n\n    const stylizeResult = (vs: string[]) => postprocess(vs.map(mapper).join(separator))\n\n    const mixFilter = (\n        {fullKey, num, fullOccur, values}: Tag,\n        {store, deferred, ready}: Internals,\n    ) => {\n        const id = `${fullKey}:${fullOccur}`\n        const waitingSetKey = `${fullKey}:waitingList`\n        const applyKey = `${id}:apply`\n\n        if (store.get(applyKey, false)) {\n            const waitingSet = store.get(waitingSetKey, new Set()) as Set<string>\n            if (waitingSet.size > 0) {\n                return\n            }\n\n            const popped = []\n            const possibleValues = store.get(fullKey, []) as unknown[]\n\n            for (let x = 0; x < values[0].length; x++) {\n                popped.push(possibleValues.pop())\n            }\n\n            return stylizeResult(popped)\n        }\n\n        if (!ready) {\n            store.over(waitingSetKey, (s: Set<string>) => s.add(id), new Set())\n            return\n        }\n\n        if (!num) {\n            return stylizeResult(shuffle(values[0]) as string[])\n        }\n\n        store.fold(fullKey, (v: unknown[]) => v.concat(values[0]), [])\n\n        // mix with num is ready for shuffling\n        deferred.registerIfNotExists(applyKey, () => {\n            store.set(applyKey, true)\n            store.over(waitingSetKey, (set: Set<string>) => set.delete(id), new Set())\n        })\n\n        const mixKey = `${fullKey}:mix`\n        deferred.registerIfNotExists(mixKey, () => {\n            store.fold(fullKey, shuffle, [])\n        })\n    }\n\n    filterApi.register(keyword, mixFilter as any)\n}\n\nexport default mixRecipe\n","import mixRecipe from './mix'\nimport ordRecipe from './ord'\nimport clozeRecipe from './cloze'\nimport mcRecipe from './mc'\nimport debugRecipe from './debug'\n\nconst recipes = {\n    shuffling: mixRecipe,\n    ordering: ordRecipe,\n    cloze: clozeRecipe,\n    multipleChoice: mcRecipe,\n    debug: debugRecipe,\n}\n\nexport default recipes\n","import type {\n    Tag\n} from '../../tags'\n\nimport type {\n    FilterApi\n} from '../filters'\n\nimport type {\n    Internals,\n} from '..'\n\nconst ordRecipe = (keyword: string) => (filterApi: FilterApi) => {\n    const ordFilter = (\n        {}: Tag,\n        {}: Internals,\n    ) => {\n    }\n\n    filterApi.register(keyword, ordFilter as any)\n}\n\nexport default ordRecipe\n","import type {\n    Tag\n} from '../../tags'\n\nimport type {\n    FilterApi\n} from '../filters'\n\nimport type {\n    Internals,\n} from '..'\n\nconst clozeRecipe = (keyword: string) => (filterApi: FilterApi) => {\n    const clozeFilter = (\n        {}: Tag,\n        {}: Internals,\n    ) => {\n    }\n\n    filterApi.register(keyword, clozeFilter as any)\n}\n\nexport default clozeRecipe\n","import type {\n    Tag\n} from '../../tags'\n\nimport type {\n    FilterApi\n} from '../filters'\n\nimport type {\n    Internals,\n} from '..'\n\nconst mcRecipe = (keyword: string) => (filterApi: FilterApi) => {\n    const mcFilter = (\n        {}: Tag,\n        {}: Internals,\n    ) => {\n    }\n\n    filterApi.register(keyword, mcFilter as any)\n}\n\nexport default mcRecipe\n","import type {\n    FilterApi,\n} from '../filters'\n\nimport type { Tag } from '../../tags'\n\nconst debugRecipe = (filterApi: FilterApi) => {\n    const pathFilter = ({path}: Tag) => path.join(':')\n\n    filterApi.register('tagpath', pathFilter as any)\n    filterApi.register('never', (() => {}) as any) \n    filterApi.register('empty', (() => '') as any)\n    filterApi.register('k', (({key}) => key) as any)\n}\n\nexport default debugRecipe\n","import renderTemplate from './main'\nimport FilterManager from './filterManager'\nimport filterRecipes from './filterManager/recipes'\n\nglobalThis.renderTemplate = renderTemplate\nglobalThis.FilterManager = FilterManager\nglobalThis.filterRecipes = filterRecipes\n"],"names":["rootTag","this","zoom","TemplateApi","path","currentPos","path_1","__values","p","innerTags","traverse","maybeTagInfo","data","start","root","factory","Rule","name","symbols","postprocess","id","highestId","State","rule","dot","reference","wantedBy","isComplete","length","Column","grammar","index","states","wants","scannable","completed","Grammar","rules","byName","forEach","hasOwnProperty","push","StreamLexer","reset","Parser","options","fromCompiled","key","keepHistory","lexer","lexerState","undefined","column","table","predict","process","current","prototype","toString","withCursorAt","stringifySymbolSequence","e","literal","JSON","stringify","type","symbolSequence","map","join","slice","nextState","child","state","left","right","build","children","node","reverse","finish","fail","nextColumn","w","i","complete","exp","nulls","r","s","copy","Lexer","ParserStart","ParserRules","g","buffer","line","lastLineBreak","col","next","ch","value","save","formatError","token","message","nextLineBreak","indexOf","substring","Array","feed","chunk","n","text","constructor","expect","test","isToken","err","Error","reportError","offset","results","lines","tokenDisplay","lastColumnIndex","filter","nextSymbol","buildFirstStateStack","stateStack","symbolDisplay","getSymbolDisplay","displayStateStack","lastDisplay","sameDisplayCount","j","display","symbol","RegExp","visited","prevState","childVisited","concat","childResult","restore","splice","rewind","considerations","t","c","module","exports","nearley","tokenizer","Object","hasSticky","sticky","isRegExp","o","call","isObject","isArray","reCapture","reUnion","regexps","regexpOrLiteral","obj","replace","ignoreCase","global","multiline","source","ruleOptions","match","include","defaultType","lineBreaks","error","fallback","pop","shouldThrow","sort","a","b","toRules","spec","array","result","arrayToRules","object","keys","getOwnPropertyNames","thing","objectToRules","defaultErrorRule","compileRules","hasStates","errorRule","fast","create","fastAllowed","unicodeFlag","groups","parts","shift","charCodeAt","unicode","pat","regexp","exec","fallbackRule","flags","suffix","checkStateGroup","startState","stack","info","queuedToken","queuedThrow","setState","re","popState","pushState","eat","tokenToString","_getGroup","groupCount","queuedGroup","_token","queuedText","group","charAt","lastIndex","matchNL","nl","size","Symbol","iterator","LexerIterator","done","Math","max","eol","firstLine","clone","has","tokenType","compile","all","$all","ruleMap","included","newRules","k","newRule","apply","fastKeys","freeze","keywords","reverseMap","byLength","types","item","keyword","str","x","Function","moo","main","tagstart","EOF","keyname","sep","tagend","intag","valuestext","fullKey","num","valuesRaw","fullOccur","occur","values","split","arg","splitValues","Tag","newValuesRaw","_ready","TagInfo","end","naked","_end","_data","_naked","isReadyRecursive","tag","keyPattern","tagCounter","Map","TagMaker","get","set","idx","Number","getAndInc","tagKeeper","tm","getTagInfo","tagStack","nextLevel","_b","startIndex","addInnerTag","endIndex","abs","close","makeTag","d","tk","TagKeeper","_a","_c","endToken","startToken","rest","vtxt","v","parseTemplate","parsed","console","restart","postfixTraverse","baseText","filterProcessor","tagReduce","ready","modText","modStack","modReady","innerOffset","leftOffset","_d","tagStart","tagEnd","lend","rend","tagData","shadowValuesRaw","log","filterOutput","newOffset","newText","add","leftend","min","spliceSlice","sum","defaultMemoizer","hasItem","makeMemoizerKey","getItem","setItem","removeItem","delete","clear","store","Store","defaultValue","f","mempty","wrapWithNonMemoize","memoize","standardizeFilterResult","wf","input","baseFilter","getRawRepresentation","rawFilter","defaultFilter","getDefaultRepresentation","filters","FilterApi","maybeResult","internals","getOrDefault","getFilterKey","deferred","DeferredApi","proc","register","_i","args","name_1","func","notReady","preset","memoizer","FilterManager","stock","custom","_this","assign","execute","executeEach","recipe","recipes","shuffling","separator","mapper","filterApi","shuffle","currentIndex","temporaryValue","randomIndex","floor","random","stylizeResult","vs","waitingSetKey","applyKey","Set","popped","possibleValues","fold","registerIfNotExists","over","mixKey","ordering","cloze","multipleChoice","debug","globalThis","renderTemplate","filterManager","templateApi","executeAndClearDeferred","filterRecipes"],"mappings":"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"}